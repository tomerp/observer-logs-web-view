<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Observer Logs</title>
    <style>
      body { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; margin: 0; }
      header { display: flex; gap: 16px; align-items: center; padding: 8px 12px; background: #111; color: #eee; }
      #counts { display: flex; gap: 12px; }
      #counts span { padding: 2px 6px; border-radius: 4px; background: #222; }
      #counts .warn { background: #5c4b00; }
      #counts .err { background: #5c0000; }
      #counts .crit { background: #7a0034; }
      #log { height: calc(100vh - 64px); overflow: auto; padding: 8px 12px; background: #000; color: #ddd; white-space: pre; }
      #notices { height: 20px; line-height: 20px; font-size: 12px; color: #aaa; padding: 0 12px; background: #0a0a0a; border-top: 1px solid #111; }
      .INFO { color: #9aa7ff; }
      .WARNING { color: #ffd666; }
      .ERROR { color: #ff6b6b; }
      .CRITICAL { color: #ff66a1; font-weight: bold; }
      .UNKNOWN { color: #aaa; }
      #status { margin-left: auto; font-size: 12px; opacity: 0.8; }
      input, button { font-family: inherit; }
    </style>
  </head>
  <body>
    <header>
      <div>Observer Logs</div>
      <div id="counts">
        <span class="warn">WARN(60m): <b id="warn">0</b></span>
        <span class="err">ERROR(60m): <b id="err">0</b></span>
        <span class="crit">CRIT(60m): <b id="crit">0</b></span>
        <span>Round: <b id="round">-</b></span>
        <span>Since last round: <b id="since">-</b>s</span>
      </div>
      <div id="status">disconnected</div>
      <input id="token" placeholder="token" />
      <button id="connect">Connect</button>
    </header>
    <div id="notices"></div>
    <div id="log"></div>
    <script>
      const log = document.getElementById('log');
      const notices = document.getElementById('notices');
      const statusEl = document.getElementById('status');
      const warnEl = document.getElementById('warn');
      const errEl = document.getElementById('err');
      const critEl = document.getElementById('crit');
      const roundEl = document.getElementById('round');
      const sinceEl = document.getElementById('since');
      const tokenInput = document.getElementById('token');
      const connectBtn = document.getElementById('connect');

      let ws; let reconnectTimer; let token = localStorage.getItem('observer_token') || '';
      tokenInput.value = token;

      function appendLine(evt) {
        const div = document.createElement('div');
        div.className = evt.level;
        div.textContent = evt.raw;
        log.appendChild(div);
        if (log.childElementCount > 10000) log.firstElementChild.remove();
        // Only autoscroll for live events, not for massive seed batches
        if (!evt.seed) {
          log.scrollTop = log.scrollHeight;
        }
      }

      async function hydrateRecent() {
        const url = new URL('/api/v1/recent', location.origin);
        if (token) url.searchParams.set('token', token);
        url.searchParams.set('limit', '5000');
        try {
          const res = await fetch(url.toString());
          const data = await res.json();
          log.innerHTML = '';
          for (const e of data.events) appendLine(e);
        } catch {}
      }

      function connect() {
        if (ws) ws.close();
        const url = new URL('/ws', location.origin.replace('http', 'ws'));
        if (token) url.searchParams.set('token', token);
        ws = new WebSocket(url.toString());
        ws.onopen = () => { statusEl.textContent = 'connected'; };
        ws.onclose = () => { statusEl.textContent = 'disconnected'; clearTimeout(reconnectTimer); reconnectTimer = setTimeout(connect, 2000); };
        ws.onmessage = (m) => {
          try {
            const msg = JSON.parse(m.data);
            if (msg.type === 'line') appendLine(msg.data);
            if (msg.type === 'stats') {
              warnEl.textContent = msg.data.totals.WARNING;
              errEl.textContent = msg.data.totals.ERROR;
              critEl.textContent = msg.data.totals.CRITICAL;
              if (msg.data.lastRound) roundEl.textContent = msg.data.lastRound;
              if (msg.data.secondsSinceLastRound != null) sinceEl.textContent = msg.data.secondsSinceLastRound;
            }
            if (msg.type === 'notice') {
              notices.textContent = msg.data.msg;
            }
          } catch {}
        };
      }

      connectBtn.onclick = () => {
        token = tokenInput.value.trim();
        localStorage.setItem('observer_token', token);
        hydrateRecent().then(connect);
      };

      hydrateRecent().then(connect);
    </script>
  </body>
  </html>


